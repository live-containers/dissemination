\chapter{Background Concepts} \label{chap:background}

\section{Containers} \label{sec:containers}

Jordi, you might add comments using \texttt{\textbackslash jg} command \jg{like this}.

An Introduction to containers, what are they used for, some data, ...

\subsection{An Introduction to Virtualization}

Introduce the concepts of virtualization and process isolation, what is a virtual machine

\subsection{Working Principles of Containers}

Relatively deep dive into containers:

\subsubsection*{Control Groups}

\subsubsection*{Namespaces}

\subsubsection*{Putting it all together}

Mention the different alternatives for container runtimes

\subsection{Container Orchestrators}

\jg{We are not focusing on orchestrators in the thesis, so this section might not be necessary. In fact, their support for checkpointing and migration depends on the underlying containerization engine and, as far as I know, none of them exploits this functionality. Orchestrators might have a relevant role for distributed checkpointing (we could mention this), but again, I am not aware of any orchestrator providing that. We might do some investigation to confirm.}

\subsection{State-of-the-Art for Virtualization Techniques}

\jg{Same comment here. I do not think this is needed as background for the thesis.}

Mention some novel techniques in the area:

- Microkernels

- Lightweight VM

- Serverless

- Cloud native

\section{Checkpointing}

Brief introduction, what is checkpointing

\subsection{Checkpoint-Restore}

\subsection{Live Migration}

Iterative, pre-copy, post-copy, ... \cite{Clark2005}

\subsection{Distributed Checkpointing}

\section{\criu: Checkpoint Restore in Userspace}

Checkpoint/Restore in Userspace (\criu) is an open-source C/R tool~\cite{criu-main-page}.
Introduced in 2011, it's distinctive feature is that it is mainly implemented in user space, rather than in the kernel, by using existing interfaces~\cite{Reber2016}.
One of the most important interface is \texttt{ptrace}~\cite{ptrace-manpage}, as it relies on it for seizing the target process.
For other interfaces, several patches have been pushed to the mainline kernel by \criu developers~\cite{criu-kernel-patches}.
The project is currently under active development~\cite{criu-github}, and its main focus is to support the migration of containers.

\subsection{A Technical Overview on \criu}

The main goal of \criu is to perform a snapshot the current process' tree state to a set of image files, so that it can be later restored that exact point in time, without reproducing the steps that led to it.

\subsubsection*{Checkpoint}

The checkpointing process starts with the process identifier (PID) of a process group leader provided by the user through the command line using the \texttt{--tree} option~\cite{criu-checkpoint}.
However, before it can actually start, we need to ensure that the process does not change it's state during checkpoint.
This includes: opening file descriptors, changing sessions, or even producing new child processes~\cite{criu-feeze}.
To achieve this transparently, instead of sending a stop signal (which could affect the process' state) \criu freezes tasks using \texttt{ptrace}'s \texttt{PTRACE\_SEIZE} command~\cite{ptrace-manpage}.
In order to find all active tasks descendant of the parent PID, the \texttt{\$pid} dumper iterates through each \texttt{/proc/\$pid/task/} entry, recursively gathering threads and their children from \texttt{/proc/\$pid/task/\$tid/children}.

Once all tasks are frozen, \criu collects all the information it can about the task's resources.
File descriptors and registers are dumped through a \texttt{ptrace} interface and are parsed from \texttt{/proc/\$pid/fd} and \texttt{/proc/\$pid/stat} respectively.
In order to dump the contents of memory and credentials, a novel technique is introduced, the \textbf{parasite code}.

The parasite code is a binary blob built as a position independent executable (PIE) for execution inside another process adress space.
It's purpose is to execute \criu calls from within the dumpee's task address space~\cite{criu-parasite}.
To achieve this goal, \criu must:
\begin{enumerate}
    \item Move task into seized state calling \texttt{ptrace(PTRACE\_SEIZE, ...)}. Note that the task is stopped without it noticing, hence not altering it's state.
    \item Inject an \texttt{mmap} syscall in the current stack's instruction pointer, and allocate memory for the whole code blob. At this stage, space for exchanging parameters and results is also allocated within the dumpee's process adress space.
\end{enumerate}

\subsubsection*{Restore}

\subsection{Comparison with Other C/R Tools}

We can beneffit from this table:

- \url{https://criu.org/Comparison_to_other_CR_projects}

Compare:

- VM C/R

- CRIU

- DMTCP

- BLCR

- FTI: maybe this falls a bit out of the scope \url{https://github.com/leobago/fti}

We could also include snippets of how to run a Hello World for each alternative.

