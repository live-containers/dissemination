\chapter{Background Concepts} \label{chap:background}

\section{Containers} \label{sec:containers}

Jordi, you might add comments using \texttt{\textbackslash jg} command \jg{like this}.

An Introduction to containers, what are they used for, some data, ...

\subsection{An Introduction to Virtualization}

Virtualization is a recurrent technique in systems design in computer science which aims to provide processes the illusion that they interact with a defined interface, hiding the real implementation behind.
Some of the most relevant features facilitated by virtualization are: process isolation from other processes and the underlying system, fine-grained dynamic resource provisioning, multiple virtually dedicated subsystems on the same physical instance, among others.
We classify virtualization techniques according to the type of interface being virtualized.

\textbf{Emulation.}
Emulators allow applications written for a certain computer architecture to run on a different one.
They do so by translating (\textit{i.e.} virtualizing) the Instruction Set Architecture (ISA).
An example of such a system is \textsc{Qemu} (\url{https://www.qemu.org/}).

\textbf{Hardware Virtualization.}
Hardware virtualization interfaces a complete system which enables to run a fully-featured operating system within a different one.
It has traditionally been one of the most user-friendly virtualization tools in the form of \emph{virtual machines} such as the Linux-Kernel Virtual Machine \textsc{KVM} (\url{https://www.linux-kvm.org/page/Main_Page}, \textsc{VMWare Workstation} (\url{https://www.vmware.com/}) or Oracle's \textsc{VirtualBox} (\url{https://www.virtualbox.org/}).
We differentiate between full virtualization and paravirtualization.
The former adds an hypervisor or virtual machine monitor (VMM) which creates the illusion of multiple virtual machines, which are multiplexed across the physical resources, and allow to run an \emph{unmodified} guest OS.
The latter modifies the guest OS' source code and replaces sensitive calls with \emph{hypercalls}, which are direct calls to the hypervisor.

\textbf{OS-level Virtualization.}
Operating Sytem-level virtualization allows for multiple isolated user-space instances, called \textbf{containers} which share a single operating system.
In comparison to traditional virtual machines, containers add little overhead, require minimal startup, and have a low resource requirement, all this factors make them highly scalable.
Containers have experienced an exponential increase in usage, specially with the advent of open-source highly-available container engines such as \textsc{Docker} (\url{https://www.docker.com/}), Linux Containers \textsc{LXC} (\url{https://linuxcontainers.org/}), \textsc{Podman} (\url{https://podman.io/}, among others.
Given that the goal of this project is to perform efficient live migration of running containers, the following section provides further technical details on containerization.

\subsection{Working Principles of Containers}

As previously introduced, a linux container is a set of processes that are isolated from the rest of the machine.
To achieve this isolation, they rely on two kernel features: control groups and namespaces~\cite{namespaces-manual}.

\subsubsection*{Namespaces}

As greatly phrased by Michael Kerrisk in his series of articles on namespaces~\cite{Kerrisk2013}, the purpose of namespaces is to wrap a global system resource and abstract it in a way that each process within the namespace thinks it has its own isolated instance of such resource.
As of Kernel 5.6, there are eight different types of namespaces, which we present together with a brief description and their respective flag in Table~\ref{table:namespaces}.
\begin{table}[h!]
    \centering
    \rowcolors{1}{gray!20}{}
    \begin{tabular}{p{2cm}p{13cm}}
        \hline
        \textbf{Kind} & \textbf{Description} \\[3pt]
        \hline \hline
        \texttt{mnt} & \textbf{Mount namespaces} provide isolation of the list of mount points seen by the process in each namespace instance. It allow processes to have their own root file system and mount and unmount file systems without affecting the rest of the system. \\[3pt]
        \texttt{pid} & The \textbf{process ID} isolates the PID number space. This means that two processes in different PID namespaces can have the same identifier. It is very useful in container migration as it allows to restore the processes with the same PID they were dumped with regardless of whether that ID might be taken in the target machine or not. \\[3pt]
        \texttt{net} & \textbf{Network namespaces} provide isolation of the whole network stack. In particular network devices, interfaces, routing tables, iptables rules, and sockets. \\[3pt]
        \texttt{ipc} & The \textbf{Interprocess Comunication namespace} provides isolation for POSIX semaphore queues, semaphore sets and shared memory segments.\\[3pt]
        \texttt{uts} & The \textbf{UNIX Time Sharing namespace} allows processes to set a hostname or domainname for that particular namespace without affecting the rest of the system. \\[3pt]
        \texttt{user} & \textbf{User namespaces} isolate security-related identifiers such as user and group identifiers (UID, GID) and capabilities. This allows for a process to have privileges within a certain namespace but not outside it's scope. \\[3pt]
        \texttt{cgroup} & The \textbf{Control Group namespace} virtualizes the contents of \texttt{/proc/self/cgroup}. As a consequence each different namespace has a different cgroup root directory.\\[3pt]
        \texttt{time} & The \textbf{time namespace} has been the latest addition to the group. Included in Kernel 5.6, it allows different namespaces to have different offsets to the system monotonic and boot-time clock.\\[3pt]
        \hline
    \end{tabular}
    \caption{List of the different namespaces supported in Kernel 5.6. and a brief description of the isolation they provide.\label{table:namespaces}}
\end{table}
In order to create a new namespace of a given time, we can follow two approaches.
With the \texttt{clone} system call, we can create a new child process, in a similar way to \texttt{fork} but with higher control of what pieces of execution context are inherited~\cite{clone-manual}.
More specifically, with the \texttt{unshare} system call we can specifically unshare a namespace from parent process~\cite{unshare-manual}.
To join an existing namespace, we can use the \texttt{setns} syscall, which given a file descriptor referring to a namespace, it links the calling process to it.~\cite{setns-manual}.
These operations require the \texttt{CAP\_SYS\_ADMIN} capability.
In Listings~\ref{code:namespaces-unshare} and~\ref{code:namespaces-setns} we include examples of usage of \texttt{unshare} and \texttt{setns} respectively.
\begin{figure}[h!]
    \begin{minipage}{.45\textwidth}
        \begin{lstlisting}[language=C,caption={Snippet to unshare the calling thread from a namespace using the \texttt{unshare} system call.\label{code:namespaces-unshare}}]
#define _GNU_SOURCE
#include <errno.h>
#include <sched.h>
#include <stdio.h>

// Unshare from parent namespace
int main(int argc, char *argv[])
{
    /* Available flags:
     * CLONE_NEWCGROUP, CLONE_NEWIPC
     * CLONE_NEWNS, CLONE_NEWNET
     * CLONE_NEWPID, CLONE_NEWTIME
     * CLONE_NEWUTS, CLONE_NEWUSER
     */
    flags = CLONE_NEWNET || CLONE_NEWPID;

    if (unshare(flags) == -1)
    {
        perror("unshare failed");
        exit(EXIT_FAILURE);        
    }

    return 0;
}
\end{lstlisting}
    \end{minipage} \hfill
    \begin{minipage}{.45\textwidth}
        \begin{lstlisting}[language=C,caption={Scripts to perfrom two pre-dumps and a dump of a running process using CRIU.\label{code:namespaces-setns}}]
#define _GNU_SOURCE
#include <errno.h>
#include <sched.h>
#include <stdio.h>

// Attach calling process to an existing
// network namespace.
int main(int argc, char *argv[])
{
    // Get namespace FD
    fd = open("/proc/330/ns/net", O_RDONLY);

    // Join the namespace
    if (setns(fd, CLONE_NEWNET) == -1)
    {
        perror("setns failed");
        exit(EXIT_FAILURE);        
    }

    return 0;
}
\end{lstlisting}
    \end{minipage}
\end{figure}

\subsubsection*{Control Groups}

Control groups (\texttt{cgroups}) are a resource management kernel feature that allows handling of processes in hierarchical groups.
This way, fine-grained resource metering and limiting can be applied on a per-group basis.
Typical resources monitored using this technique are memory, CPU usage, I/O network, ...

These constraints are enforced through the usage of kernel subsystems.
Each different subsystem, mapped to one of the resources to manage, has an independent hierarchy.
Each process then belongs to exactly one group per subsystem.
For instance, the memory cgroup keeps track of the pages used and imposes different limits for physical, kernel, and total memory.

\subsubsection*{Different Container Runtimes}


\section{Checkpointing}

Brief introduction, what is checkpointing

\subsection{Checkpoint-Restore}

\subsection{Live Migration}

Iterative, pre-copy, post-copy, ... \cite{Clark2005}

\subsection{Distributed Checkpointing}

\section{\criu: Checkpoint Restore in Userspace}

Checkpoint/Restore in Userspace (\criu) is an open-source C/R tool~\cite{criu-main-page}.
Introduced in 2011, it's distinctive feature is that it is mainly implemented in user space, rather than in the kernel, by using existing interfaces~\cite{Reber2016}.
One of the most important interface is \texttt{ptrace}~\cite{ptrace-manpage}, as it relies on it for seizing the target process.
For other interfaces, several patches have been pushed to the mainline kernel by \criu developers~\cite{criu-kernel-patches}.
The project is currently under active development~\cite{criu-github}, and its main focus is to support the migration of containers.

\subsection{A Technical Overview on \criu}

The main goal of \criu is to perform a snapshot the current process' tree state to a set of image files, so that it can be later restored that exact point in time, without reproducing the steps that led to it.

\subsubsection*{Checkpoint}

The checkpointing process starts with the process identifier (PID) of a process group leader provided by the user through the command line using the \texttt{--tree} option~\cite{criu-checkpoint}.
However, before it can actually start, we need to ensure that the process does not change it's state during checkpoint.
This includes: opening file descriptors, changing sessions, or even producing new child processes~\cite{criu-freeze}.
To achieve this transparently, instead of sending a stop signal (which could affect the process' state) \criu freezes tasks using \texttt{ptrace}'s \texttt{PTRACE\_SEIZE} command~\cite{ptrace-manpage}.
In order to find all active tasks descendant of the parent PID, the \texttt{\$pid} dumper iterates through each \texttt{/proc/\$pid/task/} entry, recursively gathering threads and their children from \texttt{/proc/\$pid/task/\$tid/children}.

Once all tasks are frozen, \criu collects all the information it can about the task's resources.
File descriptors and registers are dumped through a \texttt{ptrace} interface and are parsed from \texttt{/proc/\$pid/fd} and \texttt{/proc/\$pid/stat} respectively.
In order to dump the contents of memory and credentials, a novel technique is introduced, the \textbf{parasite code}.

The parasite code is a binary blob built as a position independent executable (PIE) for execution inside another process adress space.
It's purpose is to execute \criu calls from within the dumpee's task address space~\cite{criu-parasite-code}.
To achieve this goal, \criu must:
\begin{enumerate}
    \item Move task into seized state calling \texttt{ptrace(PTRACE\_SEIZE, ...)}. Note that the task is stopped without it noticing, hence not altering it's state.
    \item Inject an \texttt{mmap} syscall in the current stack's instruction pointer, and allocate memory for the whole code blob. At this stage, space for exchanging parameters and results is also allocated within the dumpee's process adress space. \criu is now ready to run parasite service routines.
    \item The external dumping process retrieves information about the dumpee's adrress space through the parasite code either through \emph{trap} mode (one command at a time) or \texttt{daemon} mode (in which the parasite behavies as a UNIX socket.
    \item With information about used memory areas and important flags read from \texttt{/proc/\$pid/smaps/} and \texttt{/proc/\$pid/pagemap}, the parasite code transfers the actual content outside through a set of pipes, which in turn gets translated into image files.
\end{enumerate}
Lastly, the target process is cured from the parasite by closing it, unmapping it's allocated memory area, and reverting to the original frozen state.

\subsubsection*{Restore}

During the restore process, \criu morphs into the to-be-restored task.
Since we checkpoint process trees rather than single processes, \criu must \texttt{fork} itself several times to recreate the original PID tree.
In particular, and in order to be completely transparent, \criu requires that the restored tasks have the same PID they had before dump.
To achieve this goal, older versions of \criu had to perform very time-sensitive and race condition-prone PID handling, what was referred to as the PID dance~\cite{Reber2019,criu-pid-dance}.
Starting with kernel 5.3 and the new \texttt{clone3()} system call, it becomes now possible to clone a process and specify the desired PID for it~\cite{kernel-clone3}.

Then \criu restores all basic task resources such as file descriptors, namespaces, maps, ...
The only resources that are \emph{not} restored at this stage are, most notably, memory mappings.
In order to restore memory areas, and since the morphing is done \textit{in-place}, before exitting \criu would have to unmap itself and map the application code.
To overcome this issue, a similar approach to the parasite code one is followed, the \textbf{restorer blob}.
The restorer blob is a piece of PIE code, to which \criu transfers control to unmap itself and map the appropriate code and memory areas for the process to restore successfully.

\subsubsection*{Live Migration with Criu}

TO-DO

\subsection{Comparison with Other C/R Tools}

We can beneffit from this table:

- \url{https://criu.org/Comparison_to_other_CR_projects}

Compare:

- VM C/R

- CRIU

- DMTCP

- BLCR

- FTI: maybe this falls a bit out of the scope \url{https://github.com/leobago/fti}

We could also include snippets of how to run a Hello World for each alternative.

